---
title: web前端基础 -- 前端工程化
date: 2021-02-28 19:45:04
permalink: /pages/38823c/
---
# web前端基础 -- 前端工程化

## 前端工程化

前端项目从开发到部署的一系列解决方案。

### 为什么需要前端工程化

### 具体可以解决哪些问题？

1. 模块化开发 - 核心问题
2. 优化开发体验，使开发者的精力聚焦于逻辑实现

```
thinking:
一个网页应用，js代码总量超过2000行怎么实现

方案一：写在一个文件（不易阅读）
方案二：按功能划分，写成多个js文件，再由多个标签引用（请求时长增加）

最好的idea:
开发时，模块化开发
运行时，打包合并引用
```

### 模块化

模块化开发有哪些好处？

1. 可维护性：以模块为单位编写代码，降低对整体系统的依赖；方便多人协作
2. 可复用性：同一个功能多次使用时，引用同一个模块，避免重复实现  (npm)
3. 可读性：结构清晰，便于理解。

## JS模块化

### 原生语法支持 ：es6 Module

```js
//index.js
import {add} from "./math.js";
import print from "./print.js";

let result = add(1,2);
console.log(result);

//math.js
export function add(a,b){
	return a+b;
}

//print.js
export default function print(str){
	console.log(str);
}
```

### es6之前

CommonJs

```js
//模块导入 
const {add} = require('./math.js');

//模块导出
exports
```

###  打包

根据模块间依赖关系将多个模块合并为一个文件

常见的打包工具：webpack，rollup

```
webpack 
entry:{
	index:""//确定哪一个是主文件 模块的入口
},
npm run bulid
```

## webPack

一切皆模块

```js
//loder机制

module.exports = {
	entry:{
	index:"./src/index.js"//确定哪一个是主文件 模块的入口
	},
	
	module:{
		rules:[{
			test:/\.css$/,//正则匹配
			use:{
				'style-loder',
				'css-loder'
			},
            {
            test:/\.js$/,
            exclud : /node_moduiea/,
            use:{
            loader:"babel-loder",
            options:{
            presets :["@babel/preset-env"]
        }
        }
        	}
           ]
        }
	},
}
```

## 组件化

组件化：将页面（或应用），按组件拆分模块开发，通过组件的组合拼装实现页面

// 复用性好

组件库   santd 

## 开发体验优化

1. 本地调试

   > 生产环境 ： 浏览器通过http请求从服务器获取前端代码
   >
   > 开发环境 ： 浏览器如何运行本地编写中的前端代码？ ==webpack-dev-server== 在本地开启一个简易的调试服务，让浏览器从本地服务地址请求前端代码。热跟新
   >
   > file 协议 http存在跨域问题

2. babel

   > bai bo
   >
   > ES 2015 => 转换为低版本 js 语法（兼容）
   >
   > * plugin : 语法特性
   > * preset ：插件的预设

3. css预处理器

   > 一种能用自己的语法生成css的程序
   >
   > * sass
   > * less
   > * stylue
   >
   > 写法更简洁
   >
   > 复用
   >
   > （变量，mixin，函数）